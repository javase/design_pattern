# 访问者模式

# 定义：
封装某些作用于某种数据结构中各元素的操作，
它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
***
定义2：
在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，
它改变了元素类的执行算法。
通过这种方式，元素的执行算法可以随着访问者改变而改变。
这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，
这样访问者对象就可以处理元素对象上的操作。

# 意图：
主要将数据结构与数据操作分离。

# 主要解决：
稳定的数据结构和易变的操作耦合问题。

# 何时使用：
需要对一个对象结构中的对象进行很多不同的并且不相关的操作，
而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。

# 如何解决：
在被访问的类里面加一个对外提供接待访问者的接口。

# 关键代码：
在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。

# 应用实例：
您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，
然后对朋友的描述做出一个判断，这就是访问者模式。

# 优点： 
1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。

# 缺点： 
1、具体元素对访问者公布细节，违反了迪米特原则。 
2、具体元素变更比较困难。 
3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。

# 使用场景： 
1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 
2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，
而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。

# 注意事项：
访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。

# 访问者模式的优点
* 符合单一职责原则：
凡是适用访问者模式的场景中，
元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，
使用访问者模式一方面符合单一职责原则，另一方面，
因为被封装的操作通常来说都是易变的，所以当发生变化时，
就可以在不改变元素类本身的前提下，实现对变化部分的扩展。
* 扩展性良好：
元素类可以通过接受不同的访问者来实现对不同操作的扩展。

# 总结
正如《设计模式》的作者GoF对访问者模式的描述：
大多数情况下，你并不需要使用访问者模式，但是当你一旦需要使用它时，
那你就是真的需要它了。
当然这只是针对真正的大牛而言。
在现实情况下（至少是我所处的环境当中），很多人往往沉迷于设计模式，
他们使用一种设计模式时，从来不去认真考虑所使用的模式是否适合这种场景，
而往往只是想展示一下自己对面向对象设计的驾驭能力。
编程时有这种心理，往往会发生滥用设计模式的情况。
所以，在学习设计模式时，一定要理解模式的适用性。
必须做到使用一种模式是因为了解它的优点，不使用一种模式是因为了解它的弊端；
而不是使用一种模式是因为不了解它的弊端，不使用一种模式是因为不了解它的优点。